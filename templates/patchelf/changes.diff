Changes applied to the upstream version #e03e1644dc
(https://github.com/NixOS/patchelf/blob/e03e1644dc/src/patchelf.cc)

--- patchelf.cc	2015-09-09 08:41:42.221881338 +0200
+++ patchelf.cpp	2015-09-09 08:39:37.557879210 +0200
@@ -1,3 +1,21 @@
+/*
+ *  Copyright (c) 2004-2015 Eelco Dolstra <eelco.dolstra@logicblox.com>
+ *  https://github.com/NixOS/patchelf
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or (at
+ *  your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
 #include <string>
 #include <vector>
 #include <set>
@@ -17,7 +35,11 @@
 #include <fcntl.h>
 #include <limits.h>
 
-#include "elf.h"
+#if (defined HAVE_ELF_H)
+    #include <elf.h>
+#else
+    #include "../inc/elf.h"
+#endif
 
 using namespace std;
 
@@ -154,7 +176,7 @@
 
     void setInterpreter(const string & newInterpreter);
 
-    typedef enum { rpPrint, rpShrink, rpSet, rpRemove } RPathOp;
+    typedef enum { rpPrint, rpShrink, rpSet, rpRemove, rpConvert } RPathOp;
 
     void modifyRPath(RPathOp op, string newRPath);
 
@@ -164,6 +186,8 @@
     
     void replaceNeeded(map<string, string>& libs);
 
+    void printNeededLibs();
+
     void noDefaultLib();
 
 private:
@@ -236,12 +260,11 @@
 }
 
 
-static void readFile(string fileName, mode_t * fileMode)
+static void readFile(string fileName)
 {
     struct stat st;
     if (stat(fileName.c_str(), &st) != 0) error("stat");
     fileSize = st.st_size;
-    *fileMode = st.st_mode;
     maxSize = fileSize + 32 * 1024 * 1024;
 
     contents = (unsigned char *) malloc(fileSize + maxSize);
@@ -1138,9 +1161,17 @@
         return;
     }
 
+    /* Check if a DT_RPATH that could be converted to DT_RUNPATH exists. */
+    if (op == rpConvert && !rpath) {
+        debug("no RPATH to convert\n");
+        return;
+    }
 
     if (string(rpath ? rpath : "") == newRPath) return;
 
+    /* convert DT_RPATH to DT_RUNPATH */
+    if (op == rpConvert && rpath) newRPath = string(rpath ? rpath : "");
+
     changed = true;
 
     /* Zero out the previous rpath to prevent retained dependencies in
@@ -1159,8 +1190,10 @@
         dynRPath = 0;
     }
 
-    if (forceRPath && dynRPath && dynRunPath) { /* convert DT_RUNPATH to DT_RPATH */
-        dynRunPath->d_tag = DT_IGNORE;
+    if (forceRPath && !dynRPath && dynRunPath) { /* convert DT_RUNPATH to DT_RPATH */
+        dynRunPath->d_tag = DT_RPATH;
+        dynRPath = dynRunPath;
+        dynRunPath = 0;
     }
 
     if (newRPath.size() <= rpathSize) {
@@ -1321,6 +1354,23 @@
     changed = true;
 }
 
+template<ElfFileParams>
+void ElfFile<ElfFileParamNames>::printNeededLibs()
+{
+    Elf_Shdr & shdrDynamic = findSection(".dynamic");
+    Elf_Shdr & shdrDynStr = findSection(".dynstr");
+    char *strTab = (char *)contents + rdi(shdrDynStr.sh_offset);
+
+    Elf_Dyn *dyn = (Elf_Dyn *) (contents + rdi(shdrDynamic.sh_offset));
+
+    for (; rdi(dyn->d_tag) != DT_NULL; dyn++) {
+        if (rdi(dyn->d_tag) == DT_NEEDED) {
+            char *name = strTab + rdi(dyn->d_un.d_val);
+            printf("%s\n", name);
+        }
+    }
+}
+
 
 template<ElfFileParams>
 void ElfFile<ElfFileParamNames>::noDefaultLib()
@@ -1367,19 +1417,20 @@
 static bool setSoname = false;
 static string newSoname;
 static string newInterpreter;
-
 static bool shrinkRPath = false;
 static bool removeRPath = false;
 static bool setRPath = false;
 static bool printRPath = false;
+static bool convertRPath = false;
 static string newRPath;
 static set<string> neededLibsToRemove;
 static map<string, string> neededLibsToReplace;
 static set<string> neededLibsToAdd;
+static bool printNeeded = false;
 static bool noDefaultLib = false;
 
 template<class ElfFile>
-static void patchElf2(ElfFile & elfFile, mode_t fileMode)
+static void patchElf2(ElfFile & elfFile)
 {
     elfFile.parse();
 
@@ -1402,9 +1453,13 @@
         elfFile.modifyRPath(elfFile.rpShrink, "");
     else if (removeRPath)
         elfFile.modifyRPath(elfFile.rpRemove, "");
+    else if (convertRPath)
+        elfFile.modifyRPath(elfFile.rpConvert, "");
     else if (setRPath)
         elfFile.modifyRPath(elfFile.rpSet, newRPath);
 
+    if (printNeeded) elfFile.printNeededLibs();
+
     elfFile.removeNeeded(neededLibsToRemove);
     elfFile.replaceNeeded(neededLibsToReplace);
     elfFile.addNeeded(neededLibsToAdd);
@@ -1421,14 +1476,12 @@
 
 static void patchElf()
 {
-    if (!printInterpreter && !printRPath && !printSoname)
+    if (!printInterpreter && !printRPath && !printSoname && !printNeeded)
         debug("patching ELF file `%s'\n", fileName.c_str());
 
     debug("Kernel page size is %u bytes\n", getPageSize());
 
-    mode_t fileMode;
-
-    readFile(fileName, &fileMode);
+    readFile(fileName);
 
 
     /* Check the ELF header for basic validity. */
@@ -1441,13 +1494,13 @@
         contents[EI_VERSION] == EV_CURRENT)
     {
         ElfFile<Elf32_Ehdr, Elf32_Phdr, Elf32_Shdr, Elf32_Addr, Elf32_Off, Elf32_Dyn, Elf32_Sym> elfFile;
-        patchElf2(elfFile, fileMode);
+        patchElf2(elfFile);
     }
     else if (contents[EI_CLASS] == ELFCLASS64 &&
         contents[EI_VERSION] == EV_CURRENT)
     {
         ElfFile<Elf64_Ehdr, Elf64_Phdr, Elf64_Shdr, Elf64_Addr, Elf64_Off, Elf64_Dyn, Elf64_Sym> elfFile;
-        patchElf2(elfFile, fileMode);
+        patchElf2(elfFile);
     }
     else {
         error("ELF executable is not 32/64-bit, little/big-endian, version 1");
@@ -1460,16 +1513,18 @@
         fprintf(stderr, "syntax: %s\n\
   [--set-interpreter FILENAME]\n\
   [--print-interpreter]\n\
-  [--print-soname]\t\tPrints 'DT_SONAME' entry of .dynamic section. Raises an error if DT_SONAME doesn't exist\n\
-  [--set-soname SONAME]\t\tSets 'DT_SONAME' entry to SONAME. Raises an error if DT_SONAME doesn't exist\n\
+  [--print-soname]\n\
+  [--set-soname SONAME]\n\
   [--set-rpath RPATH]\n\
   [--remove-rpath]\n\
   [--shrink-rpath]\n\
   [--print-rpath]\n\
   [--force-rpath]\n\
+  [--convert-rpath]\n\
   [--add-needed LIBRARY]\n\
   [--remove-needed LIBRARY]\n\
   [--replace-needed LIBRARY NEW_LIBRARY]\n\
+  [--print-needed]\n\
   [--no-default-lib]\n\
   [--debug]\n\
   [--version]\n\
@@ -1532,6 +1587,12 @@
                added. */
             forceRPath = true;
         }
+        else if (arg == "--convert-rpath") {
+            convertRPath = true;
+        }
+        else if (arg == "--print-needed") {
+            printNeeded = true;
+        }
         else if (arg == "--add-needed") {
             if (++i == argc) error("missing argument");
             neededLibsToAdd.insert(argv[i]);
